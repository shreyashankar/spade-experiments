,func A,func B,A -> B,asked_LLM
0,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
1,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
2,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
3,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
4,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
5,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
6,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
7,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
8,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
9,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",False,True
10,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
11,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,True
12,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
13,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
14,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
15,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
16,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,True
17,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
18,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",False,True
19,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
20,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
21,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
22,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
23,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
24,"async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
25,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",True,True
26,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",True,True
27,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,True
28,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,True
29,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",True,True
30,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,True
31,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",True,True
32,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",True,True
33,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,True
34,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
35,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",True,True
36,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,True
37,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,True
38,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",True,True
39,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,True
40,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",True,True
41,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",True,True
42,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",True,True
43,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",True,True
44,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",True,True
45,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,True
46,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",True,True
47,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",True,True
48,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",True,True
49,"async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",True,True
50,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,False
51,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
52,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
53,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
54,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
55,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
56,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
57,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
58,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
59,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
60,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
61,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,False
62,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
63,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
64,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
65,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
66,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,False
67,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
68,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",False,False
69,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
70,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
71,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
72,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
73,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
74,"async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
75,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",True,True
76,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,True
77,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,True
78,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,True
79,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",True,True
80,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",True,True
81,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,True
82,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,True
83,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",True,True
84,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
85,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",True,True
86,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",True,True
87,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",True,True
88,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",True,True
89,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",True,True
90,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",True,True
91,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",True,True
92,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,True
93,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",True,True
94,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",True,True
95,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,True
96,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",True,True
97,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",True,True
98,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",True,True
99,"async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,True
100,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",True,True
101,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,True
102,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",True,True
103,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,True
104,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",True,True
105,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,True
106,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",True,True
107,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,True
108,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",True,True
109,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
110,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",True,True
111,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,True
112,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,True
113,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",True,True
114,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",True,True
115,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",True,True
116,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,True
117,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,True
118,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",False,True
119,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,True
120,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",True,True
121,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,True
122,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,True
123,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",True,True
124,"async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",True,True
125,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,False
126,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
127,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
128,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
129,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
130,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
131,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
132,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
133,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
134,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
135,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
136,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,False
137,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
138,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
139,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
140,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
141,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,False
142,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
143,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",False,False
144,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
145,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
146,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
147,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
148,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
149,"async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
150,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,True
151,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",True,True
152,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",True,True
153,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,True
154,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,True
155,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,True
156,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",True,True
157,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,True
158,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,True
159,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
160,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",True,True
161,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,True
162,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,True
163,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",True,True
164,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,True
165,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",True,True
166,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",True,True
167,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",True,True
168,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",True,True
169,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,True
170,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",True,True
171,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,True
172,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",True,True
173,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",True,True
174,"async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",True,True
175,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,False
176,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
177,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
178,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
179,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
180,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
181,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
182,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
183,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
184,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
185,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
186,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,False
187,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
188,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
189,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
190,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
191,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,False
192,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
193,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",False,False
194,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
195,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
196,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
197,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
198,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
199,"async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
200,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,True
201,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
202,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
203,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
204,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
205,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
206,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
207,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
208,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
209,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",False,True
210,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
211,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,True
212,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
213,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
214,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
215,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
216,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,True
217,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,True
218,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",False,True
219,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
220,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
221,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
222,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
223,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
224,"async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
225,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,True
226,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
227,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
228,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
229,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
230,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
231,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
232,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
233,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
234,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
235,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
236,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,True
237,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
238,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
239,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
240,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
241,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,True
242,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
243,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",True,True
244,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
245,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
246,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
247,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
248,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
249,"async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
250,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,False
251,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
252,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
253,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
254,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
255,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
256,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
257,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
258,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
259,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
260,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
261,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,False
262,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
263,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
264,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
265,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
266,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,False
267,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
268,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",False,False
269,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
270,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
271,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
272,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
273,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
274,"async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
275,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,False
276,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
277,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
278,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
279,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
280,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
281,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
282,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
283,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
284,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
285,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
286,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,False
287,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
288,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
289,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
290,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
291,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,False
292,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
293,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",False,False
294,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
295,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
296,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
297,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
298,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
299,"async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
300,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",True,True
301,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
302,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
303,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
304,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
305,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
306,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
307,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
308,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
309,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
310,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
311,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
312,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
313,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
314,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
315,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
316,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",True,True
317,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
318,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",True,True
319,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
320,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
321,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
322,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
323,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
324,"async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
325,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,True
326,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
327,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",True,True
328,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
329,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
330,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
331,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
332,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
333,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",True,True
334,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",True,True
335,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
336,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",True,True
337,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",True,True
338,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
339,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
340,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
341,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",True,True
342,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,True
343,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",True,True
344,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
345,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",True,True
346,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
347,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
348,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",True,True
349,"async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
350,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",True,True
351,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",True,True
352,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",True,True
353,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",True,True
354,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",True,True
355,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
356,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",True,True
357,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
358,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",True,True
359,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",True,True
360,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
361,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
362,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",True,True
363,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",True,True
364,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",True,True
365,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
366,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,False
367,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",True,True
368,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",True,True
369,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",True,True
370,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",True,True
371,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",True,True
372,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",True,True
373,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
374,"async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
375,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",True,True
376,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
377,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",True,True
378,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
379,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
380,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
381,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
382,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",True,True
383,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",True,True
384,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
385,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
386,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",True,True
387,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,True
388,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
389,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
390,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",True,True
391,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",True,True
392,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",True,True
393,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",True,True
394,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
395,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",True,True
396,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
397,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",True,True
398,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",True,True
399,"async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
400,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,False
401,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
402,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
403,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
404,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
405,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
406,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
407,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
408,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
409,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
410,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
411,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
412,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,False
413,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
414,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
415,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
416,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,False
417,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
418,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",False,False
419,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
420,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
421,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
422,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
423,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
424,"async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
425,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,True
426,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
427,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
428,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
429,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
430,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
431,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
432,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
433,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
434,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
435,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
436,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
437,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",True,True
438,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
439,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
440,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
441,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
442,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
443,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",True,True
444,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
445,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
446,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
447,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
448,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
449,"async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
450,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,True
451,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
452,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
453,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
454,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
455,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
456,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
457,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
458,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,True
459,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
460,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
461,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
462,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,True
463,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
464,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
465,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
466,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
467,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,True
468,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",False,True
469,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
470,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
471,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
472,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
473,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
474,"async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
475,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,True
476,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
477,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
478,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
479,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
480,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
481,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
482,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
483,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
484,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
485,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",False,True
486,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
487,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,True
488,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
489,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
490,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
491,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
492,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",True,True
493,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
494,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
495,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
496,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
497,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
498,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
499,"async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
500,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,True
501,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,True
502,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",True,True
503,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",True,True
504,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",True,True
505,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,True
506,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",True,True
507,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",True,True
508,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",True,True
509,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,True
510,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
511,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",True,True
512,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,True
513,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",True,True
514,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",True,True
515,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,True
516,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",True,True
517,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",True,True
518,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,True
519,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",True,True
520,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",True,True
521,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",True,True
522,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",True,True
523,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",True,True
524,"async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",True,True
525,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",True,True
526,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
527,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
528,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
529,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
530,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
531,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
532,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
533,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,True
534,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
535,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
536,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
537,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,True
538,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
539,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
540,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
541,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
542,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",True,True
543,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,True
544,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",True,True
545,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
546,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
547,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
548,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
549,"async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
550,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",True,True
551,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
552,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",True,True
553,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
554,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
555,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
556,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
557,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
558,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
559,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
560,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
561,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",True,True
562,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,True
563,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
564,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
565,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
566,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",True,True
567,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",True,True
568,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
569,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",True,True
570,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
571,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
572,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
573,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",True,True
574,"async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
575,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,False
576,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
577,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",True,True
578,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
579,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
580,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
581,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
582,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
583,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
584,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
585,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
586,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
587,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,False
588,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
589,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
590,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
591,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
592,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,False
593,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
594,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",False,False
595,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
596,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
597,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
598,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
599,"async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
600,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",False,False
601,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
602,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
603,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
604,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
605,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
606,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
607,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
608,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
609,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
610,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
611,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
612,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",False,False
613,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
614,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
615,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
616,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
617,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,False
618,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
619,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",False,False
620,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
621,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
622,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
623,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
624,"async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
","async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
",False,False
625,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_as_markdown_format(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response is in markdown format.
    """"""
    patterns = [
        r""^#{1,6}\s"",  # Header
        r""^\s*[-*]\s"",  # Unordered list
        r""^\s*\d+\.\s"",  # Ordered list
        r""\[.+\]\(.+\)"",  # Link
        r""\*\*.+\*\*"",  # Bold text
        r""\*.+\*"",  # Italic text
        r""`[^`]+`"",  # Inline code
        r""^```\n[\s\S]*?\n```"",  # Fenced code block
    ]

    # Check if any pattern matches
    for pattern in patterns:
        if re.search(pattern, response, re.MULTILINE):
            return True

    return False
",True,True
626,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_name_present_in_routine(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response contains a section about the name of the routine.
    """"""
    return f""### \""{example['vid_name']}\"" Routine:"" in response
",False,False
627,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_name_without_follow_along(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the routine name does not contain 'follow along'.
    """"""
    return ""follow along"" not in response.lower()
",False,False
628,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_summary_suitability_and_presence(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that there is a summary section and it's not too long.
    """"""
    if ""**Summary:**"" not in response:
        return False
    summary_content = response.split(""**Summary:**"")[-1]
    summary_sentences = summary_content.split(""."")
    return (
        0 < len(summary_sentences) <= 3
    )  # Assumes a couple of sentences can mean two or three.
",False,False
629,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_equipment_section_availability(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Verify that the response contains a section listing the necessary equipment.
    """"""
    return ""**Equipment Needed:**"" in response
",False,False
630,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_post_exercise_repetitions(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that the number of repetitions or the time is placed after the exercise name.
    """"""
    # Typically, this can be achieved by pattern matching, but we assume ask_llm is a fallback.
    return not any(
        exercise_time in desc
        for exercise_time in response.split(""\n"")
        if ""("" in exercise_time
        for desc in response.split(""\n"")
        if "":"" in desc
    )
",False,False
631,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_deduplication_side_exercises(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check that exercises performed on both sides mention 'on each side' without repetition in the list.
    """"""
    return ""on each side"" in response and response.count(
        ""on each side""
    ) == response.count(""("")
",False,False
632,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_non_splitable_routine_check(
    example: dict, formatted_prompt: str, response: str
) -> bool:
    """"""
    Check if the response indicates the absence of a follow-along routine when applicable.
    """"""
    question = ""Does the response correctly indicate if the text does not contain a follow-along routine that can be split into exercises?""
    return await ask_llm(formatted_prompt, response, question)
",False,False
633,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_response_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format.
    """"""
    return response.startswith(""# "") and ""\n## "" in response and ""\n### "" in response
",False,False
634,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_routine_name_response_start(example: dict, prompt: str, response: str):
    """"""
    Check if the response starts with the routine name.
    """"""
    routine_name = example[""vid_name""].replace(""follow along"", """").strip()
    return response.lstrip(""# "").startswith(routine_name)
",False,False
635,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_absence_of_follow_along_in_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the 'follow along' text is removed from the routine name.
    """"""
    return ""follow along"" not in response.split(""\n"", 1)[0].lower()
",True,True
636,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_summary_section_target_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Check if there is a summary section that describes the routine and the target audience.
    """"""
    question = ""Is there a separate summary section below the routine name that describes the routine and its target audience, in no more than a couple of sentences?""
    return await ask_llm(prompt, response, question)
",False,False
637,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_equipment_section_existence(example: dict, prompt: str, response: str):
    """"""
    Check if there is a separate equipment section in the response.
    """"""
    if ""## Equipment"" not in response:
        return False
    equipment_section_index = response.index(""## Equipment"")
    return response[equipment_section_index:].count(""\n"") > 1
",True,True
638,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_exercises_with_time_or_reps_post_name(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the exercises are listed with reps or time directly after the exercise name.
    """"""
    exercises_section = response.split(""## Exercises\n"", 1)[-1]
    for exercise in exercises_section.strip().split(""\n\n""):
        if not exercise.startswith(""### "") or ""("" not in exercise:
            return False
    return True
",False,False
639,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_no_repeat_exercises_both_sides(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercises done on both sides are not repeated and have 'on each side' included.
    """"""
    question = ""Are there any exercises listed for the right side and left side separately, instead of mentioning once with 'on each side'?""
    # The LLM will return True if there is an error; we need to invert that result
    return not await ask_llm(prompt, response, question)
",False,False
640,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_no_text_below_exercise_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no additional text below the exercises list.
    """"""
    exercises_ending = ""### Cool-Down and Stretch:""
    return exercises_ending in response and not response.strip().endswith(
        exercises_ending
    )
",False,False
641,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_alternative_for_no_routine(example: dict, prompt: str, response: str):
    """"""
    Check for an alternative response when the text does not contain a follow-along routine that can be split into exercises.
    """"""
    question = ""If the text does not contain a follow-along routine, does the response indicate so?""
    return await ask_llm(prompt, response, question)
",False,False
642,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_completeness_and_correctness_of_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check the response for correctness and completeness, including summaries, equipment, and exercise lists.
    """"""
    question = ""Does the response include a complete and correct summary, equipment list, and exercises list while adhering to the specified format?""
    return await ask_llm(prompt, response, question)
",False,False
643,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_markdown_format(example: dict, prompt: str, response: str):
    """"""
    Check if the response is in markdown format by looking for markdown headers (e.g., '#', '##', '###').
    """"""
    expected_headers = [""# "", ""## "", ""### ""]
    return all(header in response for header in expected_headers)
",False,False
644,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_presence_headers_summary_equipment_exercises(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response contains specific headers 'Summary', 'Equipment', and 'Exercises'.
    """"""
    required_headers = [""## Summary"", ""## Equipment"", ""## Exercises""]
    return all(header in response for header in required_headers)
",True,True
645,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_no_text_post_exercises_list(example: dict, prompt: str, response: str):
    """"""
    Check that there is no text below the exercises list in the response.
    """"""
    exercises_end_index = response.rfind(""###"") + response.rsplit(""###"", 1)[-1].rfind(
        ""\n""
    )
    return exercises_end_index == len(response.strip())
",False,False
646,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_descriptions_under_exercise_header(
    example: dict, prompt: str, response: str
):
    """"""
    Check that exercise descriptions appear under the 'Exercises' header.
    """"""
    try:
        exercises_start_index = response.index(""## Exercises"")
        exercises_end_index = response.index(""### "", exercises_start_index)
        return (
            response[exercises_start_index:exercises_end_index].strip()
            == ""## Exercises""
        )
    except Exception as e:
        return False
",False,False
647,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_no_duplicate_side_exercise(example: dict, prompt: str, response: str):
    """"""
    Verify that if an exercise is performed on both sides, it is stated only once with 'on each side'.
    """"""
    exercises_segment = response.split(""## Exercises"")[-1]
    return (
        ""on each side"" in exercises_segment
        and ""left side"" not in exercises_segment
        and ""right side"" not in exercises_segment
    )
",False,False
648,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_no_redundant_information_in_response(
    example: dict, prompt: str, response: str
):
    """"""
    Check if the response does not repeat the same information twice, especially within the exercise instructions.
    """"""
    exercises_content = response.split(""## Exercises"")[-1]
    unique_content = set()
    for line in exercises_content.split(""\n""):
        if line.strip() and line.strip() in unique_content:
            return False
        unique_content.add(line.strip())
    return True
",False,False
649,"async def assert_response_completeness_and_correctness(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the response demonstrates correctness and completeness by accurately representing the details of the routine.
    """"""
    question = ""Does the response accurately represent the details of the given mobility routine, including the correct exercise names and descriptions?""
    return await ask_llm(prompt, response, question)
","async def assert_follow_along_routine_description(
    example: dict, prompt: str, response: str
):
    """"""
    Use ask_llm to determine if the given text contains a follow-along routine that one can split into exercises.
    """"""
    question = (
        ""Does the text contain a follow-along routine that can be split into exercises?""
    )
    return await ask_llm(prompt, response, question)
",False,False
